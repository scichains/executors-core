{
  "app": "executor",
  "version": "0.0.1",
  "category": "files",
  "name": "Find next path from list of files",
  "id": "fc6b1ee7-051b-4f23-840b-9afd95d992da",
  "language": "java",
  "java": {
    "class": "net.algart.executors.modules.core.files.FindNextFile"
  },
  "in_ports": [
    {
      "value_type": "scalar",
      "name": "file",
      "caption": "file/folder",
      "hint": "[Optional] String path to the file or folder. If specified, it is used instead of \"File/folder\" parameter (with all replacements performed in that parameter)."
    }
  ],
  "out_ports": [
    {
      "value_type": "scalar",
      "name": "output",
      "hint": "Actual full absolute path to the next file from the list."
    },
    {
      "value_type": "scalar",
      "name": "file_index"
    },
    {
      "value_type": "scalar",
      "name": "number_of_files"
    },
    {
      "value_type": "scalar",
      "name": "list_of_files"
    },
    {
      "value_type": "scalar",
      "hint": "Flag true/false: it will be true while reading the last file from the folder.\nCurrent file index is reset to 0 in this case.",
      "name": "last"
    },
    {
      "value_type": "scalar",
      "name": "absolute_path",
      "hint": "Actual full absolute path to the file. Identical to the content of the main output port."
    },
    {
      "value_type": "scalar",
      "name": "parent_folder",
      "hint": "Absolute path to the parent folder of the file."
    },
    {
      "value_type": "scalar",
      "name": "file_name",
      "hint": "Actual file name (without folder)."
    }  ],
  "controls": [
    {
      "caption": "File/folder",
      "name": "file",
      "description": "Folder to scan or file to return. If it is a folder, this function scans all files/subfolders in this folder, matching \"Globbing pattern\" parameter, and returns them while sequential calls. If it is an existing regular file, this function just returns it.\nYou can use here relative paths (without starting \"/\" or \"c:\\\"), for example, \"test\" or \"samples/test\". They will be resolved relative the current folder, containing the executed chain.\nIf this path starts with substring %TEMP%, %TEMP%/ or %TEMP%x. where x is OS-depended file separator character, this substring is replaced with the full path to the system temp directory (System.getProperty(\"java.io.tmpdir\")) with ending file separator. For example, it is correct to write here %TEMP%my_folder, %TEMP%/my_folder or (in Windows) %TEMP%\\my_folder.\nAlso you can use in this string Java system properties: \"${name}\", for example: \"${java.io.tmpdir}\", and executor system properties \"${path.name.ext}\", \"${path.name}\", \"${file.name.ext}\", \"${file.name}\", \"${resources}\" (chain path/file name with/without extension, resource folder of the platform, containing this function).",
      "value_type": "String",
      "edition_type": "folder",
      "default": ""
    },
    {
      "name": "fileNameAdditionMode",
      "caption": "How to add \"file name addition\" (for example XXX.DAT)",
      "description": "This mode can be used together with input string \"file name addition\"",
      "value_type": "String",
      "edition_type": "enum",
      "items": [
        {
          "value": "NONE",
          "caption": "no correction (\"file name addition\" is not used)"
        },
        {
          "value": "AFTER_ALL_PATH",
          "caption": "after all path: /path => /pathXXX.DAT"
        },
        {
          "value": "REPLACE_IN_PATH",
          "caption": "replace $$$ in path: /path/name$$$.ext => /path/nameXXX.DAT.ext"
        },
        {
          "value": "REPLACE_IN_PATH_REMOVING_EXTENSION",
          "caption": "replace $$$ with the addition, but without its extension: /path/name$$$.ext => /path/nameXXX.ext"
        }
      ],
      "default": "NONE"
    },
    {
      "caption": "Secure mode",
      "name": "secure",
      "description": "If set, \"file name addition\" feature and Java system properties in the path are disabled, and the path is checked that it does not contain \"suspicious\" characters/substring like %, $, {. Executor system properties \"${path.name.ext}\", \"${path.name}\", \"${file.name.ext}\", \"${file.name}\" and starting %TEMP%/ are enabled.",
      "value_type": "boolean",
      "edition_type": "value",
      "default": false
    },
    {
      "caption": "Globbing pattern",
      "name": "globPattern",
      "description": "This function finds all files/folders, matching the specified pattern: see \"getPathMatcher\" Java method. This pattern is used ONLY if the file/folder parameter actually specifies a folder; it is not used in the case of a regular file.\nTypical examples: * (all files/folders), *.* (file names containing a dot), *.{jpeg,jpg,png,gif,bmp} (files with the specified extensions).",
      "value_type": "String",
      "edition_type": "value",
      "default": "*"
    },
    {
      "caption": "Regular expression",
      "name": "regularExpression",
      "description": "If this parameter is non-empty (contains some non-space character), it must contain some regular expression (leading and trailing space are removed). Every path, matching the \"Globbing pattern\", is additionally checked that it also matches this regular expression, and if does not, it is removed from the result list.\nIn other words, you may specify * in \"Globbing pattern\" (i.e. \"any path\") and use the regular expression to detect, do you need a file/folder or no.\nExample: .*\\.(txt|dat)$  means all paths ending with \".txt\" or \".dat\".\nNote: this regular expression is checked BEFORE corrections of file names, specified by \"Absolute paths\" and \"Remove extensions\" parameters. In particular, the checked path is usually absolute.",
      "value_type": "String",
      "edition_type": "value",
      "advanced": true,
      "default": ""
    },
    {
      "caption": "How to sort the result list",
      "name": "sortOrder",
      "value_type": "String",
      "edition_type": "enum",
      "items": [
        {
          "value": "STANDARD",
          "caption": "Standard (alphabetically)"
        },
        {
          "value": "SUBDIRECTORIES_FIRST",
          "caption": "Alphabetically, but subdirectories before files"
        },
        {
          "value": "SUBDIRECTORIES_LAST",
          "caption": "Alphabetically, but files before subdirectories"
        }
      ],
      "default": "STANDARD"
    },
    {
      "caption": "Return 1 path",
      "name": "singlePath",
      "description": "If this flag is set, as well as if \"File/folder\" is an existing regular file, this function does not perform scanning and just returns \"File/folder\" parameter as the single result. \"Globbing pattern\" is ignored in this case.\nThis feature should be useful if the output list of files is passed into some function, that sometimes works with a single file/folder, but sometimes with a series of files. For example, it can be a function for reading array of images either from a given TIFF, or from some set of files/folders specified by user: in this case, this flag can control desired working mode. Usually this flag should be cleared.",
      "value_type": "boolean",
      "edition_type": "value",
      "default": false
    },
    {
      "caption": "Recursive scanning",
      "name": "recursiveScanning",
      "description": "If set, the folder specified above is scanned recursively. If cleared, subfolders of the specified folder are not scanned.",
      "value_type": "boolean",
      "edition_type": "value",
      "default": false
    },
    {
      "caption": "Requires existing file",
      "name": "fileExistenceRequired",
      "description": "If set, at least 1 file, corresponding the pattern, must exist in the folder; in other case, this function will throw an exception.\nIf this flag is cleared and there are no files to read, this function returns non-initialized result.",
      "value_type": "boolean",
      "edition_type": "value",
      "default": false
    }
  ]
}