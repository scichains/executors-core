/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2017-2024 Daniel Alievsky, AlgART Laboratory (http://algart.net)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.algart.executors.modules.core.numbers.arithmetic;

import net.algart.executors.api.ReadOnlyExecutionInput;
import net.algart.executors.api.data.SNumbers;
import net.algart.executors.modules.core.common.numbers.NumbersFilter;

import java.util.stream.IntStream;

public final class NumbersTrigonometry extends NumbersFilter implements ReadOnlyExecutionInput {
    public static final String OUTPUT_SIN = "sin";
    public static final String OUTPUT_COS = "cos";
    public static final String OUTPUT_TAN = "tan";
    public static final String OUTPUT_ASIN = "asin";
    public static final String OUTPUT_ACOS = "acos";
    public static final String OUTPUT_ATAN = "atan";

    private boolean degrees = false;
    private double resultMultiplier = 1.0;

    public NumbersTrigonometry() {
        useVisibleResultParameter();
        removeOutputPort(DEFAULT_OUTPUT_PORT);
        addOutputNumbers(OUTPUT_SIN);
        addOutputNumbers(OUTPUT_COS);
        addOutputNumbers(OUTPUT_TAN);
        addOutputNumbers(OUTPUT_ASIN);
        addOutputNumbers(OUTPUT_ACOS);
        addOutputNumbers(OUTPUT_ATAN);
    }

    public boolean isDegrees() {
        return degrees;
    }

    public NumbersTrigonometry setDegrees(boolean degrees) {
        this.degrees = degrees;
        return this;
    }

    public double getResultMultiplier() {
        return resultMultiplier;
    }

    public NumbersTrigonometry setResultMultiplier(double resultMultiplier) {
        this.resultMultiplier = resultMultiplier;
        return this;
    }

    @Override
    protected SNumbers processNumbers(SNumbers sourceNumbers) {
        final float[] source = sourceNumbers.toFloatArray();
        final float[] result = new float[source.length];
        //[[Repeat() sin ==> cos,,tan,,asin,,acos,,atan;;
        //           SIN ==> COS,,TAN,,ASIN,,ACOS,,ATAN]]
        if (isOutputNecessary(OUTPUT_SIN)) {
            sin(source, result);
            getNumbers(OUTPUT_SIN).setTo(result, sourceNumbers.getBlockLength());
        }
        //[[Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! ]]
        if (isOutputNecessary(OUTPUT_COS)) {
            cos(source, result);
            getNumbers(OUTPUT_COS).setTo(result, sourceNumbers.getBlockLength());
        }
        if (isOutputNecessary(OUTPUT_TAN)) {
            tan(source, result);
            getNumbers(OUTPUT_TAN).setTo(result, sourceNumbers.getBlockLength());
        }
        if (isOutputNecessary(OUTPUT_ASIN)) {
            asin(source, result);
            getNumbers(OUTPUT_ASIN).setTo(result, sourceNumbers.getBlockLength());
        }
        if (isOutputNecessary(OUTPUT_ACOS)) {
            acos(source, result);
            getNumbers(OUTPUT_ACOS).setTo(result, sourceNumbers.getBlockLength());
        }
        if (isOutputNecessary(OUTPUT_ATAN)) {
            atan(source, result);
            getNumbers(OUTPUT_ATAN).setTo(result, sourceNumbers.getBlockLength());
        }
        //[[Repeat.AutoGeneratedEnd]]
        return null;
    }


    @Override
    protected boolean resultRequired() {
        return false;
    }

    /*Repeat() sin ==> cos,,tan*/
    private void sin(float[] source, float[] result) {
        IntStream.range(0, (source.length + 255) >>> 8).parallel().forEach(block -> {
            // note: splitting to blocks helps to provide normal speed
            if (degrees) {
                sinBlockDegrees(source, result, block);
            } else {
                sinBlockRadians(source, result, block);
            }
        });
    }

    private void sinBlockDegrees(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.sin(Math.toRadians(source[i])));
        }
    }

    private void sinBlockRadians(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.sin(source[i]));
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */
    private void cos(float[] source, float[] result) {
        IntStream.range(0, (source.length + 255) >>> 8).parallel().forEach(block -> {
            // note: splitting to blocks helps to provide normal speed
            if (degrees) {
                cosBlockDegrees(source, result, block);
            } else {
                cosBlockRadians(source, result, block);
            }
        });
    }

    private void cosBlockDegrees(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.cos(Math.toRadians(source[i])));
        }
    }

    private void cosBlockRadians(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.cos(source[i]));
        }
    }

    private void tan(float[] source, float[] result) {
        IntStream.range(0, (source.length + 255) >>> 8).parallel().forEach(block -> {
            // note: splitting to blocks helps to provide normal speed
            if (degrees) {
                tanBlockDegrees(source, result, block);
            } else {
                tanBlockRadians(source, result, block);
            }
        });
    }

    private void tanBlockDegrees(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.tan(Math.toRadians(source[i])));
        }
    }

    private void tanBlockRadians(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.tan(source[i]));
        }
    }
    /*Repeat.AutoGeneratedEnd*/

    /*Repeat() asin ==> acos,,atan*/
    private void asin(float[] source, float[] result) {
        IntStream.range(0, (source.length + 255) >>> 8).parallel().forEach(block -> {
            // note: splitting to blocks helps to provide normal speed
            if (degrees) {
                asinBlockDegrees(source, result, block);
            } else {
                asinBlockRadians(source, result, block);
            }
        });
    }

    private void asinBlockDegrees(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.toDegrees(Math.asin(source[i])));
        }
    }

    private void asinBlockRadians(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.asin(source[i]));
        }
    }
    /*Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! */
    private void acos(float[] source, float[] result) {
        IntStream.range(0, (source.length + 255) >>> 8).parallel().forEach(block -> {
            // note: splitting to blocks helps to provide normal speed
            if (degrees) {
                acosBlockDegrees(source, result, block);
            } else {
                acosBlockRadians(source, result, block);
            }
        });
    }

    private void acosBlockDegrees(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.toDegrees(Math.acos(source[i])));
        }
    }

    private void acosBlockRadians(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.acos(source[i]));
        }
    }

    private void atan(float[] source, float[] result) {
        IntStream.range(0, (source.length + 255) >>> 8).parallel().forEach(block -> {
            // note: splitting to blocks helps to provide normal speed
            if (degrees) {
                atanBlockDegrees(source, result, block);
            } else {
                atanBlockRadians(source, result, block);
            }
        });
    }

    private void atanBlockDegrees(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.toDegrees(Math.atan(source[i])));
        }
    }

    private void atanBlockRadians(float[] source, float[] result, int block) {
        for (int i = block << 8, to = (int) Math.min((long) i + 256, source.length); i < to; i++) {
            result[i] = (float) (resultMultiplier * Math.atan(source[i]));
        }
    }
    /*Repeat.AutoGeneratedEnd*/
}
